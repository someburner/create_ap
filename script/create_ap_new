#!/bin/bash

VERSION=0.4.6
PROGNAME="$(basename $0)"

unset ALL_PROXY

# Must match whatever's in Makefile
CREATE_AP_INC=/usr/share/create_ap/inc

if [[ ! -d "$CREATE_AP_INC" ]]; then
   echo "Could not locate create_ap includes.";
   exit 1;
fi

# make sure that all command outputs are in english
# so we can parse them correctly
export LC_ALL=C

# all new files and directories must be readable only by root.
# in special cases we must use chmod to give any other permissions.
SCRIPT_UMASK=0077
umask $SCRIPT_UMASK

# source usage.sh
# Vars: None
# Funcs: usage
echo "sourcing usage.sh..."
. "$CREATE_AP_INC/usage.sh"

# on success it echos a non-zero unused FD
# on error it echos 0
get_avail_fd() {
   local x
   for x in $(seq 1 $(ulimit -n)); do
      if [[ ! -a "/proc/$BASHPID/fd/$x" ]]; then
         echo $x
         return
      fi
   done
   echo 0
}

# lock file for the mutex counter
COUNTER_LOCK_FILE=/tmp/create_ap.$$.lock

# source mutex.sh:
# Vars: None
# Funcs: cleanup_lock, init_lock, mutex_lock, mutex_unlock
echo "sourcing mutex.sh..."
. "$CREATE_AP_INC/mutex.sh"

# it takes 2 arguments
# returns:
#  0 if v1 (1st argument) and v2 (2nd argument) are the same
#  1 if v1 is less than v2
#  2 if v1 is greater than v2
version_cmp() {
   local V1 V2 VN x
   [[ ! $1 =~ ^[0-9]+(\.[0-9]+)*$ ]] && die "Wrong version format!"
   [[ ! $2 =~ ^[0-9]+(\.[0-9]+)*$ ]] && die "Wrong version format!"

   V1=( $(echo $1 | tr '.' ' ') )
   V2=( $(echo $2 | tr '.' ' ') )
   VN=${#V1[@]}
   [[ $VN -lt ${#V2[@]} ]] && VN=${#V2[@]}

   for ((x = 0; x < $VN; x++)); do
      [[ ${V1[x]} -lt ${V2[x]} ]] && return 1
      [[ ${V1[x]} -gt ${V2[x]} ]] && return 2
   done

   return 0
}

USE_IWCONFIG=0

# source ifutil.sh:
# Vars: None
# Funcs: is_interface, is_wifi_interface, is_bridge_interface, get_phy_device,
# get_adapter_info, get_adapter_kernel_module, can_be_sta_and_ap, can_be_ap,
# can_transmit_to_channel, ieee80211_frequency_to_channel, is_5ghz_frequency,
# is_wifi_connected, is_unicast_macaddr, get_macaddr, get_mtu, alloc_new_iface,
# dealloc_iface, get_all_macaddrs, get_new_macaddr, haveged_watchdog
echo "sourcing ifutil.sh..."
. "$CREATE_AP_INC/ifutil.sh"

# source netman.sh:
# Vars: NETWORKMANAGER_CONF, NM_OLDER_VERSION, ADDED_UNMANAGED
# Funcs: networkmanager_exists, networkmanager_is_running,
# networkmanager_iface_is_unmanaged, networkmanager_add_unmanaged,
# networkmanager_rm_unmanaged, networkmanager_fix_unmanaged,
# networkmanager_rm_unmanaged_if_needed, networkmanager_wait_until_unmanaged
echo "sourcing netman.sh..."
. "$CREATE_AP_INC/netman.sh"

# source defaults.sh:
# Vars: A bunch
# Funcs: None
echo "sourcing defaults.sh..."
. "$CREATE_AP_INC/defaults.sh"

# source cleanup.sh:
# Vars: None
# Funcs: _clean_custom_iptables, clean_exit, die, cleanup, _cleanup
echo "sourcing cleanup.sh..."
. "$CREATE_AP_INC/cleanup.sh"

# source utils.sh:
# Vars: None
# Funcs: _clean_custom_iptables, clean_exit, die, cleanup, _cleanup
echo "sourcing utils.sh..."
. "$CREATE_AP_INC/utils.sh"

# source args.sh:
# Vars: ARGS, GETOPT_ARGS
# Funcs: None, but processes args
echo "sourcing args.sh..."
. "$CREATE_AP_INC/args.sh"

# Load positional args from config file, if needed
if [[ -n "$LOAD_CONFIG" && $# -eq 0 ]]; then
   i=0
   # set arguments in order
   for x in WIFI_IFACE INTERNET_IFACE SSID PASSPHRASE; do
      if eval "[[ -n \"\$${x}\" ]]"; then
         eval "set -- \"\${@:1:$i}\" \"\$${x}\""
         ((i++))
      fi
      # we unset the variable to avoid any problems later
      eval "unset $x"
   done
fi

# Check if required number of positional args are present
if [[ $# -lt 1 && $FIX_UNMANAGED -eq 0  && -z "$STOP_ID" &&
      $LIST_RUNNING -eq 0 && -z "$LIST_CLIENTS_ID" ]]; then
   usage >&2
   exit 1
fi

# Set NO_DNS, if dnsmasq is disabled
if [[ $NO_DNSMASQ -eq 1 ]]; then
   NO_DNS=1
fi

trap "cleanup_lock" EXIT

if ! init_lock; then
   echo "ERROR: Failed to initialize lock" >&2
   exit 1
fi

# if the user press ctrl+c or we get USR1 signal
# then run clean_exit()
trap "clean_exit" SIGINT SIGUSR1
# if we get USR2 signal then run die().
trap "die" SIGUSR2

# ifutil.sh
# check_if_settings
[[ -n "$STORE_CONFIG" ]] && write_config "$@"

if [[ $LIST_RUNNING -eq 1 ]]; then
   echo -e "List of running $PROGNAME instances:\n"
   list_running
   exit 0
fi

if [[ -n "$LIST_CLIENTS_ID" ]]; then
   list_clients "$LIST_CLIENTS_ID"
   exit 0
fi

if [[ $(id -u) -ne 0 ]]; then
   echo "You must run it as root." >&2
   exit 1
fi

if [[ -n "$STOP_ID" ]]; then
   echo "Trying to kill $PROGNAME instance associated with $STOP_ID..."
   send_stop "$STOP_ID"
   exit 0
fi

if [[ $FIX_UNMANAGED -eq 1 ]]; then
   echo "Trying to fix unmanaged status in NetworkManager..."
   networkmanager_fix_unmanaged
   exit 0
fi

if [[ $DAEMONIZE -eq 1 && $RUNNING_AS_DAEMON -eq 0 ]]; then
   echo "Running as Daemon..."
   # run a detached create_ap
   RUNNING_AS_DAEMON=1 setsid "$0" "${ARGS[@]}" &
   exit 0
fi

if [[ $FREQ_BAND != 2.4 && $FREQ_BAND != 5 ]]; then
   echo "ERROR: Invalid frequency band" >&2
   exit 1
fi

if [[ $CHANNEL == default ]]; then
   if [[ $FREQ_BAND == 2.4 ]]; then
      CHANNEL=1
   else
      CHANNEL=36
   fi
fi

if [[ $FREQ_BAND != 5 && $CHANNEL -gt 14 ]]; then
   echo "Channel number is greater than 14, assuming 5GHz frequency band"
   FREQ_BAND=5
fi

WIFI_IFACE=$1

if ! is_wifi_interface ${WIFI_IFACE}; then
   echo "ERROR: '${WIFI_IFACE}' is not a WiFi interface" >&2
   exit 1
fi

if ! can_be_ap ${WIFI_IFACE}; then
   echo "ERROR: Your adapter does not support AP (master) mode" >&2
   exit 1
fi

if ! can_be_sta_and_ap ${WIFI_IFACE}; then
   if is_wifi_connected ${WIFI_IFACE}; then
      echo "ERROR: Your adapter can not be a station (i.e. be connected) and an AP at the same time" >&2
      exit 1
   elif [[ $NO_VIRT -eq 0 ]]; then
      echo "WARN: Your adapter does not fully support AP virtual interface, enabling --no-virt" >&2
      NO_VIRT=1
   fi
fi

# source hostapd.sh:
# Vars: HOSTAPD, GETOPT_ARGS
# Funcs: None, but processes args
echo "sourcing hostapd.sh, running if_setup.."
. "$CREATE_AP_INC/hostapd.sh"
# From hostapd.sh
if_setup_checks

if [[ "$SHARE_METHOD" != "none" ]]; then
   MIN_REQUIRED_ARGS=2
else
   MIN_REQUIRED_ARGS=1
fi

if [[ $# -gt $MIN_REQUIRED_ARGS ]]; then
   if [[ "$SHARE_METHOD" != "none" ]]; then
      if [[ $# -ne 3 && $# -ne 4 ]]; then
         usage >&2
         exit 1
      fi
      INTERNET_IFACE="$2"
      SSID="$3"
      PASSPHRASE="$4"
   else
      if [[ $# -ne 2 && $# -ne 3 ]]; then
         usage >&2
         exit 1
      fi
      SSID="$2"
      PASSPHRASE="$3"
   fi
else
   if [[ "$SHARE_METHOD" != "none" ]]; then
      if [[ $# -ne 2 ]]; then
         usage >&2
         exit 1
      fi
      INTERNET_IFACE="$2"
   fi
   if tty -s; then
      while :; do
         read -p "SSID: " SSID
         if [[ ${#SSID} -lt 1 || ${#SSID} -gt 32 ]]; then
         echo "ERROR: Invalid SSID length ${#SSID} (expected 1..32)" >&2
         continue
         fi
         break
      done
      while :; do
         if [[ $USE_PSK -eq 0 ]]; then
         read -p "Passphrase: " -s PASSPHRASE
         echo
         if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -lt 8 ]] || [[ ${#PASSPHRASE} -gt 63 ]]; then
            echo "ERROR: Invalid passphrase length ${#PASSPHRASE} (expected 8..63)" >&2
            continue
         fi
         read -p "Retype passphrase: " -s PASSPHRASE2
         echo
         if [[ "$PASSPHRASE" != "$PASSPHRASE2" ]]; then
            echo "Passphrases do not match."
         else
            break
         fi
         else
         read -p "PSK: " PASSPHRASE
         echo
         if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -ne 64 ]]; then
            echo "ERROR: Invalid pre-shared-key length ${#PASSPHRASE} (expected 64)" >&2
            continue
         fi
         fi
      done
   else
      read SSID
      read PASSPHRASE
   fi
fi

if [[ "$SHARE_METHOD" != "none" ]] && ! is_interface $INTERNET_IFACE; then
   echo "ERROR: '${INTERNET_IFACE}' is not an interface" >&2
   exit 1
fi

if [[ ${#SSID} -lt 1 || ${#SSID} -gt 32 ]]; then
   echo "ERROR: Invalid SSID length ${#SSID} (expected 1..32)" >&2
   exit 1
fi

if [[ $USE_PSK -eq 0 ]]; then
   if [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -lt 8 ]] || [[ ${#PASSPHRASE} -gt 63 ]]; then
      echo "ERROR: Invalid passphrase length ${#PASSPHRASE} (expected 8..63)" >&2
      exit 1
   fi
elif [[ ${#PASSPHRASE} -gt 0 && ${#PASSPHRASE} -ne 64 ]]; then
   echo "ERROR: Invalid pre-shared-key length ${#PASSPHRASE} (expected 64)" >&2
   exit 1
fi

if [[ $(get_adapter_kernel_module ${WIFI_IFACE}) =~ ^rtl[0-9].*$ ]]; then
   if [[ -n "$PASSPHRASE" ]]; then
      echo "WARN: Realtek drivers usually have problems with WPA1, enabling -w 2" >&2
      WPA_VERSION=2
   fi
   echo "WARN: If AP doesn't work, please read: howto/realtek.md" >&2
fi

if [[ $NO_VIRT -eq 1 && "$WIFI_IFACE" == "$INTERNET_IFACE" ]]; then
   echo -n "ERROR: You can not share your connection from the same" >&2
   echo " interface if you are using --no-virt option." >&2
   exit 1
fi

mutex_lock
trap "cleanup" EXIT
CONFDIR=$(mktemp -d /tmp/create_ap.${WIFI_IFACE}.conf.XXXXXXXX)
echo "Config dir: $CONFDIR"
echo "PID: $$"
echo $$ > $CONFDIR/pid

# to make --list-running work from any user, we must give read
# permissions to $CONFDIR and $CONFDIR/pid
chmod 755 $CONFDIR
chmod 444 $CONFDIR/pid

COMMON_CONFDIR=/tmp/create_ap.common.conf
mkdir -p $COMMON_CONFDIR

if [[ "$SHARE_METHOD" == "nat" ]]; then
   echo $INTERNET_IFACE > $CONFDIR/nat_internet_iface
   cp -n /proc/sys/net/ipv4/conf/$INTERNET_IFACE/forwarding \
         $COMMON_CONFDIR/${INTERNET_IFACE}_forwarding
fi
cp -n /proc/sys/net/ipv4/ip_forward $COMMON_CONFDIR
if [[ -e /proc/sys/net/bridge/bridge-nf-call-iptables ]]; then
   cp -n /proc/sys/net/bridge/bridge-nf-call-iptables $COMMON_CONFDIR
fi
mutex_unlock

# echo "sourcing bridge.sh"
. "$CREATE_AP_INC/bridge.sh"
get_bridge_iface

if [[ $USE_IWCONFIG -eq 0 ]]; then
   iw dev ${WIFI_IFACE} set power_save off
fi

echo "sourcing vwifi.sh, running init_vwifi..."
. "$CREATE_AP_INC/vwifi.sh"
init_vwifi

mutex_lock
echo $WIFI_IFACE > $CONFDIR/wifi_iface
chmod 444 $CONFDIR/wifi_iface
mutex_unlock

if [[ -n "$COUNTRY" && $USE_IWCONFIG -eq 0 ]]; then
   iw reg set "$COUNTRY"
fi

can_transmit_to_channel ${WIFI_IFACE} ${CHANNEL} || die "Your adapter can not transmit to channel ${CHANNEL}, frequency band ${FREQ_BAND}GHz."

if networkmanager_exists && ! networkmanager_iface_is_unmanaged ${WIFI_IFACE}; then
   echo -n "Network Manager found, set ${WIFI_IFACE} as unmanaged device... "
   networkmanager_add_unmanaged ${WIFI_IFACE}

   if networkmanager_is_running; then
      networkmanager_wait_until_unmanaged ${WIFI_IFACE}
   fi

   echo "DONE"
fi

[[ $HIDDEN -eq 1 ]] && echo "Access Point's SSID is hidden!"

[[ $MAC_FILTER -eq 1 ]] && echo "MAC address filtering is enabled!"

[[ $ISOLATE_CLIENTS -eq 1 ]] && echo "Access Point's clients will be isolated!"

# hostapd config
hostapd_write_config

# initialize WiFi interface
if [[ $NO_VIRT -eq 0 && -n "$NEW_MACADDR" ]]; then
   ip link set dev ${WIFI_IFACE} address ${NEW_MACADDR} || die "$VIRTDIEMSG"
fi

ip link set down dev ${WIFI_IFACE} || die "$VIRTDIEMSG"
ip addr flush ${WIFI_IFACE} || die "$VIRTDIEMSG"

if [[ $NO_VIRT -eq 1 && -n "$NEW_MACADDR" ]]; then
   ip link set dev ${WIFI_IFACE} address ${NEW_MACADDR} || die
fi

if [[ "$SHARE_METHOD" != "bridge" ]]; then
   ip link set up dev ${WIFI_IFACE} || die "$VIRTDIEMSG"
   ip addr add ${GATEWAY}/24 broadcast ${GATEWAY%.*}.255 dev ${WIFI_IFACE} || die "$VIRTDIEMSG"
fi

# enable Internet sharing
if [[ "$SHARE_METHOD" != "none" ]]; then
   echo "Sharing Internet using method: $SHARE_METHOD"
   if [[ "$SHARE_METHOD" == "nat" ]]; then
      iptables -w -t nat -I POSTROUTING -s ${GATEWAY%.*}.0/24 ! -o ${WIFI_IFACE} -j MASQUERADE || die
      iptables -w -I FORWARD -i ${WIFI_IFACE} -s ${GATEWAY%.*}.0/24 -j ACCEPT || die
      iptables -w -I FORWARD -i ${INTERNET_IFACE} -d ${GATEWAY%.*}.0/24 -j ACCEPT || die
      echo 1 > /proc/sys/net/ipv4/conf/$INTERNET_IFACE/forwarding || die
      echo 1 > /proc/sys/net/ipv4/ip_forward || die
      # to enable clients to establish PPTP connections we must
      # load nf_nat_pptp module
      modprobe nf_nat_pptp > /dev/null 2>&1
   elif [[ "$SHARE_METHOD" == "bridge" ]]; then
      init_bridge_sharing
   fi
else
   echo "No Internet sharing"
fi

# start dhcp + dns (optional)
if [[ "$SHARE_METHOD" != "bridge" ]]; then
   if [[ $NO_DNS -eq 0 ]]; then
      DNS_PORT=5353
      iptables -w -I INPUT -p tcp -m tcp --dport $DNS_PORT -j ACCEPT || die
      iptables -w -I INPUT -p udp -m udp --dport $DNS_PORT -j ACCEPT || die
      iptables -w -t nat -I PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \
         -p tcp -m tcp --dport 53 -j REDIRECT --to-ports $DNS_PORT || die
      iptables -w -t nat -I PREROUTING -s ${GATEWAY%.*}.0/24 -d ${GATEWAY} \
         -p udp -m udp --dport 53 -j REDIRECT --to-ports $DNS_PORT || die
   else
      DNS_PORT=0
   fi

   if [[ $NO_DNSMASQ -eq 0 ]]; then
      iptables -w -I INPUT -p udp -m udp --dport 67 -j ACCEPT || die

      if which complain > /dev/null 2>&1; then
         # openSUSE's apparmor does not allow dnsmasq to read files.
         # remove restriction.
         complain dnsmasq
      fi

      umask 0033
      dnsmasq -C $CONFDIR/dnsmasq.conf -x $CONFDIR/dnsmasq.pid -l $CONFDIR/dnsmasq.leases -p $DNS_PORT || die
      umask $SCRIPT_UMASK
   fi
fi

# start access point
echo "hostapd command-line interface: hostapd_cli -p $CONFDIR/hostapd_ctrl"

if [[ $NO_HAVEGED -eq 0 ]]; then
   haveged_watchdog &
   HAVEGED_WATCHDOG_PID=$!
fi

# start hostapd (use stdbuf for no delayed output in programs that redirect stdout)
stdbuf -oL $HOSTAPD $HOSTAPD_DEBUG_ARGS $CONFDIR/hostapd.conf &
HOSTAPD_PID=$!
echo $HOSTAPD_PID > $CONFDIR/hostapd.pid

if ! wait $HOSTAPD_PID; then
   echo -e "\nError: Failed to run hostapd, maybe a program is interfering." >&2
   if networkmanager_is_running; then
      echo "If an error like 'n80211: Could not configure driver mode' was thrown" >&2
      echo "try running the following before starting create_ap:" >&2
      if [[ $NM_OLDER_VERSION -eq 1 ]]; then
         echo "   nmcli nm wifi off" >&2
      else
         echo "   nmcli r wifi off" >&2
      fi
      echo "   rfkill unblock wlan" >&2
   fi
   die
fi

clean_exit













#### EOF
